// Copyright (c) 2017 Colectica. All rights reserved
// See the LICENSE file in the project root for more information.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Diagnostics;
using Cogs.Model;

namespace Cogs.Publishers
{
    public class BuildSphinxDocumentation
    {
        private string outputDirectory;
        private CogsModel cogsModel;

        public void Build(CogsModel cogsModel, string outputDirectory)
        {
            this.cogsModel = cogsModel;
            this.outputDirectory = outputDirectory;

            //ClearOutputDirectory();
            CopySphinxStarterFiles();
            BuildTopIndex();
            BuildItemTypePages();
            BuildReusableTypePages();
            BuildTopicPages();
            //RunSphinx();
        }

        private void BuildTopIndex()
        {
            var builder = new StringBuilder();

            builder.AppendLine("Welcome to DDI Documentation, Generated by COGS");
            builder.AppendLine("================================================");
            builder.AppendLine();
            builder.AppendLine(".. toctree::");
            builder.AppendLine("   :maxdepth: 1");
            builder.AppendLine("   :caption: Topics");
            builder.AppendLine();

            foreach (var view in cogsModel.TopicIndices)
            {
                builder.AppendLine($"   topics/{view.Name}/index");
            }

            builder.AppendLine(".. toctree::");
            builder.AppendLine("   :maxdepth: 1");
            builder.AppendLine("   :caption: Full Contents");
            builder.AppendLine();
            builder.AppendLine("   item-types/index");
            builder.AppendLine("   reusable-types/index");
            builder.AppendLine();

            string mainIndexFileName = Path.Combine(outputDirectory, "source", "index.rst");
            File.WriteAllText(mainIndexFileName, builder.ToString());
        }

        private void RunSphinx()
        {
            Process proc = new Process();
            proc.StartInfo.UseShellExecute = true;
            proc.StartInfo.WorkingDirectory = outputDirectory;
            proc.StartInfo.FileName = @"make.bat";
            proc.StartInfo.Arguments = $"html";
            proc.Start();
        }

        private void ClearOutputDirectory()
        {
            if (!Directory.Exists(outputDirectory))
            {
                Directory.CreateDirectory(outputDirectory);
            }
            else
            {
                DirectoryInfo di = new DirectoryInfo(outputDirectory);
                foreach (FileInfo file in di.GetFiles())
                {
                    file.Delete();
                }
                foreach (DirectoryInfo dir in di.GetDirectories())
                {
                    dir.Delete(true);
                }
            }
        }

        private void CopySphinxStarterFiles()
        {
            Process proc = new Process();
            proc.StartInfo.UseShellExecute = true;
            proc.StartInfo.FileName = @"C:\WINDOWS\system32\xcopy.exe";
            proc.StartInfo.Arguments = $"sphinx-starter {outputDirectory} /E /I";
            proc.Start();
            proc.WaitForExit();
        }

        private void BuildItemTypePages()
        {
            BuildDataTypePages("All Item Types", "item types", "item-types", cogsModel.ItemTypes.OfType<DataType>().ToList());
        }

        private void BuildReusableTypePages()
        {
            BuildDataTypePages("All Reusable Types", "reusable types", "reusable-types", cogsModel.ReusableDataTypes);
        }

        private void BuildDataTypePages(string title, string lowerTitle, string path, List<DataType> dataTypes)
        {
            foreach (var itemType in dataTypes)
            {
                // Create a directory in the sphinx output area.
                string typeDir = Path.Combine(outputDirectory, "source", path, itemType.Name);
                Directory.CreateDirectory(typeDir);

                // Header
                var builder = new StringBuilder();
                builder.AppendLine(itemType.Name);
                for (int i = 0; i < itemType.Name.Length; i++)
                {
                    builder.Append("-");
                }
                builder.AppendLine();
                builder.AppendLine();

                // TODO Markdown to RST
                builder.AppendLine(itemType.Description);

                // TODO Properties listing
                builder.AppendLine();
                builder.AppendLine(".. contents::");
                builder.AppendLine();

                // Extends
                if (itemType.ParentTypes.Count > 0 ||
                    itemType.ChildTypes.Count > 0)
                {
                    builder.AppendLine("Item Type Hierarchy");
                    builder.AppendLine("~~~~~~~~~~~~~~~~~~~");
                    builder.AppendLine();

                    int indentLevel = 0;
                    string prefixStr = string.Empty;

                    // Output a link for each parent.
                    foreach (var parentType in itemType.ParentTypes)
                    {
                        prefixStr = "".PadLeft(indentLevel * 4);
                        if (!parentType.IsXmlPrimitive)
                        {
                            builder.AppendLine($"{prefixStr}* :doc:`{parentType.Path}`");
                        }
                        else
                        {
                            builder.AppendLine($"{prefixStr}* {parentType.Name}");
                        }

                        indentLevel++;
                    }

                    // Output a non-link line for the item iteslf.
                    prefixStr = "".PadLeft(indentLevel * 4);
                    builder.AppendLine($"{prefixStr}* **{itemType.Name}**");

                    // Output a link for each child.
                    indentLevel++;
                    foreach (var childType in itemType.ChildTypes)
                    {
                        prefixStr = "".PadLeft(indentLevel * 4);
                        if (!childType.IsXmlPrimitive)
                        {
                            builder.AppendLine($"{prefixStr}* :doc:`{childType.Path}`");
                        }
                        else
                        {
                            builder.AppendLine($"{prefixStr}* {childType.Name}");
                        }
                    }

                    builder.AppendLine();
                    builder.AppendLine();
                }


                // Generate Properties
                var propertiesBuilder = new StringBuilder();
                foreach (var property in itemType.Properties)
                {
                    // Name with underline
                    propertiesBuilder.AppendLine(property.Name);
                    propertiesBuilder.AppendLine(GetRepeatedCharacters(property.Name, "*"));
                    propertiesBuilder.AppendLine();

                    // Type
                    propertiesBuilder.AppendLine("Type");
                    if (!property.DataType.IsXmlPrimitive)
                    {
                        propertiesBuilder.AppendLine($"    :doc:`{property.DataType.Path}`");
                    }
                    else
                    {
                        propertiesBuilder.AppendLine("    " + property.DataType.Name);
                    }

                    // Cardinality
                    propertiesBuilder.AppendLine("Cardinality");
                    propertiesBuilder.AppendLine($"    {property.MinCardinality}..{property.MaxCardinality}");
                    propertiesBuilder.AppendLine();

                    // Description
                    propertiesBuilder.AppendLine(property.Description);
                    propertiesBuilder.AppendLine();
                }

                // Output the relationships graph
                builder.AppendLine("Relationships");
                builder.AppendLine("~~~~~~~~~~~~~");
                builder.AppendLine();

                if (itemType.Relationships.Count == 0)
                {
                    builder.AppendLine("This type does not have references to any item types.");
                }
                else
                {
                    builder.AppendLine(".. graphviz::");
                    builder.AppendLine();
                    builder.AppendLine("   digraph test1 {");

                    ProcessRelationships(itemType.Name, itemType.Relationships, builder);
                    builder.AppendLine("   }");
                }
                builder.AppendLine();


                // Output Properties details
                builder.AppendLine("Properties");
                builder.AppendLine("~~~~~~~~~~");
                builder.AppendLine();
                builder.AppendLine(propertiesBuilder.ToString());

                builder.AppendLine();

                string typeIndexFileName = Path.Combine(typeDir, "index.rst");
                File.WriteAllText(typeIndexFileName, builder.ToString());

            }

            // Write the all-item-types index.
            var indexBuilder = new StringBuilder();
            indexBuilder.AppendLine(title);
            for (int i = 0; i < title.Length; i++)
            {
                indexBuilder.Append("=");
            }
            indexBuilder.AppendLine();
            indexBuilder.AppendLine($"The DDI standard has {dataTypes.Count} {lowerTitle}.");
            indexBuilder.AppendLine();
            indexBuilder.AppendLine(".. toctree::");
            indexBuilder.AppendLine("   :maxdepth: 1");
            indexBuilder.AppendLine();

            foreach (var itemType in dataTypes)
            {
                indexBuilder.AppendLine($"   {itemType.Name}/index");
            }

            string allTypesIndexFileName = Path.Combine(outputDirectory, "source", path, "index.rst");
            File.WriteAllText(allTypesIndexFileName, indexBuilder.ToString());

        }

        private void ProcessRelationshipsRecursive(string sourceTypeName, List<Relationship> relationships, StringBuilder builder, HashSet<string> seenLines)
        {
            foreach (var rel in relationships)
            {
                string line = $"       \"{sourceTypeName}\" -> \"{rel.TargetItemType.Name}\" [label=\"{rel.PropertyName}\"]";
                if (seenLines.Contains(line))
                {
                    continue;
                }
                seenLines.Add(line);

                builder.AppendLine(line);

                // Dive deeper.
                ProcessRelationshipsRecursive(rel.PropertyName, rel.TargetItemType.Relationships, builder, seenLines);
            }
        }

        private void ProcessRelationships(string sourceTypeName, List<Relationship> relationships, StringBuilder builder)
        {
            foreach (var first in relationships)
            {
                string line = $"       \"{sourceTypeName}\" -> \"{first.TargetItemType.Name}\" [label=\"{first.PropertyName}\"]";
                builder.AppendLine(line);

                //foreach (var second in first.TargetItemType.Relationships)
                //{
                //    line = $"       \"{first.TargetItemType.Name}\" -> \"{second.TargetItemType.Name}\" [label=\"{second.PropertyName}\"]";
                //    builder.AppendLine(line);
                //}
            }
        }

        private string GetDataTypeRoot(string typeName)
        {
            string dataTypeRoot = string.Empty;
            if (cogsModel.ItemTypes.Any(x => x.Name == typeName))
            {
                dataTypeRoot = "item-types";
            }
            else if (cogsModel.ReusableDataTypes.Any(x => x.Name == typeName))
            {
                dataTypeRoot = "reusable-types";
            }

            return dataTypeRoot;
        }

        private string GetRepeatedCharacters(string str, string character)
        {
            var builder = new StringBuilder();
            for (int i = 0; i < str.Length; i++)
            {
                builder.Append(character);
            }

            return builder.ToString();
        }

        private void BuildTopicPages()
        {
            foreach (var view in cogsModel.TopicIndices)
            {
                string viewDirectory = Path.Combine(outputDirectory, "source", "topics", view.Name);
                string viewFileName = Path.Combine(viewDirectory, "index.rst");
                Directory.CreateDirectory(viewDirectory);

                var builder = new StringBuilder();

                builder.AppendLine(view.Name);
                builder.AppendLine(GetRepeatedCharacters(view.Name, "-"));
                builder.AppendLine();

                builder.AppendLine(view.Description);
                builder.AppendLine();

                builder.AppendLine("Item Types");
                builder.AppendLine("**********");
                builder.AppendLine();
                builder.AppendLine($"The DDI standard has {view.ItemTypes.Count} item types related to {view.Name}.");
                builder.AppendLine();

                builder.AppendLine(".. toctree::");
                builder.AppendLine("   :maxdepth: 1");
                builder.AppendLine();
                foreach (var type in view.ItemTypes)
                {
                    builder.AppendLine($"   ../../item-types/{type.Name}/index");
                }
                builder.AppendLine();

                File.WriteAllText(viewFileName, builder.ToString());
            }

        }
    }
}
