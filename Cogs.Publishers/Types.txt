using System;
using cogsBurger;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.ComponentModel.DataAnnotations;


namespace Cogs.DataAnnotations
{
    [AttributeUsage(AttributeTargets.All)]
    public class ExclusiveRangeAttribute : RangeAttribute
    {

        public ExclusiveRangeAttribute(int minimum, int maximum) : base(minimum, maximum) { }

        public override bool IsValid(object value)
        {
            // Automatically pass if value is null or empty. RequiredAttribute should be used to assert a value is not empty.
            if (value == null)
            {
                return true;
            }
            string s = value as string;
            if (s != null && String.IsNullOrEmpty(s))
            {
                return true;
            }
            dynamic val = value;
            dynamic min = Minimum;
            dynamic max = Maximum;

            if (val <= min) { return false; }
            if (val >= max) { return false; }
            return true;
        }
    }


    [AttributeUsage(AttributeTargets.All)]
    public class StringValidationAttribute : ValidationAttribute
    {
        Regex Rgx;
        List<string> Enumerations;

        public StringValidationAttribute(string[] enumerations, string pattern = null)
        {
            if (pattern != null) { this.Rgx = new Regex(pattern); }
            if (enumerations != null) { this.Enumerations = new List<string>(enumerations); }
        }

        public override bool IsValid(object value)
        {
            if(value == null)
            {
                return true;
            }
            if (Enumerations != null && !Enumerations.Contains(value.ToString())) { return false; }
            // check regex Pattern
            if (Rgx != null && !this.Rgx.IsMatch(value.ToString())) { return false; }
            return true;
        }
    }


    public struct CogsDate
    {
        public DateTimeOffset DateTime { get; set; }
        public DateTimeOffset Date { get; set; }
        public Tuple<int, int, string> GYearMonth { get; set; }
        public Tuple<int, string> GYear { get; set; }
        public TimeSpan Duration { get; set; }
        public enum CogsDateType { DateTime, Date, GYearMonth, GYear, Duration } 
        public CogsDateType UsedType { get; private set; }

        public CogsDate(CogsDateType type, object o) : this()
        {
            switch (type)
            {
                case CogsDateType.DateTime:
                    {
                        DateTime = (DateTimeOffset)o;
                        UsedType = CogsDateType.DateTime;
                        break;
                    }
                case CogsDateType.Date:
                    {
                        Date = (DateTimeOffset)o;
                        UsedType = CogsDateType.Date;
                        break;
                    }
                case CogsDateType.GYearMonth:
                    {
                        GYearMonth = (Tuple<int, int, string>)o;
                        UsedType = CogsDateType.GYearMonth;
                        break;
                    }
                case CogsDateType.GYear:
                    {
                        GYear = (Tuple<int, string>)o;
                        UsedType = CogsDateType.GYear;
                        break;
                    }
                case CogsDateType.Duration:
                    {
                        Duration = (TimeSpan)o;
                        UsedType = CogsDateType.Duration;
                        break;
                    }
            }
        }

        public CogsDate(string type, string value) : this()
        {
            if (type.Equals("datetime"))
            {
                string[] values = value.Split('-', 'T', ':', '+');
                DateTime = new DateTimeOffset(int.Parse(values[0]), int.Parse(values[1]), int.Parse(values[2]),
                        int.Parse(values[3]), int.Parse(values[4]), int.Parse(values[5]),
                        new TimeSpan(int.Parse(values[6]), int.Parse(values[7]), int.Parse(values[8])));
                UsedType = CogsDateType.DateTime;
            }
            else if (type.Equals("date"))
            {
                string[] values = value.Split('-');
                Date = new DateTime(int.Parse(values[0]), int.Parse(values[1]), int.Parse(values[2]));
                UsedType = CogsDateType.Date;
            }
            else if (type.Equals("YearMonth"))
            {
                string[] vals = value.Split('-', ' ');
                if (vals.Length == 3) { GYearMonth = new Tuple<int, int, string>(int.Parse(vals[0]), int.Parse(vals[1]), vals[2]); }
                else { GYearMonth = new Tuple<int, int, string>(int.Parse(vals[0]), int.Parse(vals[1]), null); }
                UsedType = CogsDateType.GYearMonth;
            }
            else if (type.Equals("year"))
            {
                string[] vals = value.Split(' ');
                if (vals.Length == 2) { GYear = new Tuple<int, string>(int.Parse(vals[0]), vals[1]); }
                else { GYear = new Tuple<int, string>(int.Parse(vals[1]), null); }
                UsedType = CogsDateType.GYear;
            }
            else if (type.Equals("duration"))
            {
                Duration = new TimeSpan(int.Parse(value));
                UsedType = CogsDateType.Duration;
            }
        }

        public CogsDate(DateTimeOffset item, bool isDate = false) : this()
        {
            if (isDate)
            {
                Date = item;
                UsedType = CogsDateType.Date;
            }
            else
            {
                DateTime = item;
                UsedType = CogsDateType.DateTime;
            }
        }

        public CogsDate(Tuple<int, int, string> item) : this()
        {
            GYearMonth = item;
            UsedType = CogsDateType.GYearMonth;
        }

        public CogsDate(Tuple<int, string> item) : this()
        {
            GYear = item;
            UsedType = CogsDateType.GYear;
        }

        public CogsDate(TimeSpan item) : this()
        {
            Duration = item;
            UsedType = CogsDateType.Duration;
        }

        public string GetUsedType()
        {
            switch (UsedType)
            {
                case CogsDateType.Date: { return "date"; }
                case CogsDateType.DateTime: { return "datetime"; }
                case CogsDateType.Duration: { return "duration"; }
                case CogsDateType.GYear: { return "year"; }
                case CogsDateType.GYearMonth: { return "YearMonth"; }
            }
            return null;  
        }

        public object GetValue()
        {
            switch (UsedType)
            {
                case CogsDateType.DateTime:
                    {
						if (DateTime == default(DateTimeOffset)) { return null; }
                        return DateTime.ToString("yyyy-MM-dd\\THH:mm:ss.FFFFFFFK");
                    }
                case CogsDateType.Date:
                    {
						if (Date == default(DateTimeOffset)) { return null; }
                        return Date.ToString("u").Split(' ')[0];
                    }
                case CogsDateType.GYearMonth:
                    {
						if (GYearMonth == null) { return null; }
						if(GYearMonth.Item3 != null) { return GYearMonth.Item1 + "-" + GYearMonth.Item2 + " " + GYearMonth.Item3; }
                        return GYearMonth.Item1 + "-" + GYearMonth.Item2;
                    }
                case CogsDateType.GYear:
                    {
						if (GYear == null) { return null; }
						if(GYear.Item2 != null) { return GYear.Item1 + " " + GYear.Item2; }
                        return GYear.Item1.ToString();
                    }
                case CogsDateType.Duration:
                    {
						if (Duration == default(TimeSpan)) { return null; }
                        return Duration.Ticks;
                    }
            }
            return null;
        }
    }
}